---
title: Proiezioni, griglie e risoluzioni
day: 2
---

# E se volessi Gauss-Boaga? #
Prima di addentrarci sui layer cartografici prendiamoci del tempo per capire bene come funzionano i Sistemi di Riferimento in OL3. A differenza di altre note librerie, nelle quali questo aspetto è del tutto ignorato (tanto tutti usano Google Mercator) oppure delegato a plugin aggiuntivi, OL3 fornisce un ampio supporto alla gestione dei sistemi di riferimento della mappa e dei nostri layer geografici, anche per quanto riguarda le funzioni di _trasformazione_ di coordinate e _riproiezione_ dei layer tra SR diversi.

Diciamo da subito che OL3, di per sé, conosce solo le caratteristiche dei due principali SR globali: **EPSG:3857** (quello di default alla creazione di una mappa) e **EPSG:4326**. Tuttavia con il supporto della ottima libreria [proj4js](http://proj4js.org/){:target="_blank"}, abbiamo la possibilità di definire e usare qualsiasi sistema di riferimento, posto che se ne conosca la definizione PROJ4. Una ricca fonte per ottenere tali definizioni, ed includerle direttamente nella nostra applicazione, è [epsg.io](http://epsg.io/){:target="_blank"}. Ma andiamo per passi, vediamo anzitutto come si definisce e si gestisce una _proiezione_ in OL3.

# ol.proj.Projection # 
In OL una proiezione viene gestita tramite un oggetto `ol.proj.projection`. Questo tipo di oggetto viene inizializzato tramite il codice EPSG della proiezione / SR che gli vogiamo associare.

Es.:
```javascript
var google_mercator = ol.prol.Projection("EPSG:3857"); // crea una proiezione Google Mercator
var wgs84 = ol.proj.Projection("ESPG:4326"); // crea una proiezione WGS84
```

OL è in grado di istanziare queste due proiezioni semplicemente dal codice EPSG, perché la loro definizione è già inclusa nella libreria.
Ma se volessi istanziare, ad es., una proiezione Gauss Boaga Ovest? Potrei pensare di fare così:
```javascript
var gb_ovest = ol.prol.Projection("EPSG:3003"); // crea una proiezione Gauss Boaga Ovest
```

Ma in realtà otteremo solo parte di quanto ci potremmo aspettare. OL3 utilizzerà il codice della nostra proiezione, ad es. quando dovrà chiedere dati ai servizi OGC, ma non sarà in grado di fare alcuna trasformazione di coordinate, perché non ha idea di cosa sia e come sia fatta una propiezione Gauss Boaga Ovest. Sa solo che è un qualcosa identificato dal codice EPSG 3003.

Nel caso avessimo bisogno di eseguire trasformazioni di coordinare dovremo aiutare OL3 tramite proj4js. Includendo questa libreria nella nostra applicazione e _registrando_ in essa la definizione PROJ4 della nostra proiezione, OL3 potrà delegare a proj4js le nostre richieste di trasformazione da/verso altri SR.

Supponiamo di conoscere le coordinate GB Ovest di Firenze (nel codice assegnate alla variabile `firenze_gbw`) e di voler centrare la nostra mappa con OSM su Firenze. Dal momento che alla nostra mappa è stata associata di default la proiezione EPSG:3857, dovremo trasformare le coordinate di Firenze in coordinate Google Mercator.

1. #3 - Includiamo la libreria proj4js, prendendola direttamente da cdnjs (riga 3)
2. #4 - Registriamo in proj4js la definizione della nostra proiezione. Per farlo sfruttiamo un'utilità offerta dal servizio epsg.io: inserendo un [link al codice Javascript del nostro codice EPSG](http://epsg.io/3003.js){:target="_blank"}, epsg.io inserirà direttamente il codice per eseguire la registrazione `proj4.defs(...)`
3. #7 - Assegniamo a `firenze_gbw` le coordinate GB Ovest, in forma di array
4. #9 - Creiamo un oggetto _proeizione_ di OL3 assegnandogli il codice EPSG:3003. A questo punto OL3 cercherà questo codice all'interno delle proprie definizioni e, se presente, di proj4js.
5. #13 - Tramite la funzione statica `ol.proj.transform` eseguiamo la trasformazione di coordinate, passandogli le coordinaate di partenza, la proeizione di origine e quella di destinazione. Notate che per l'origine abbiamo usato la nostra istanza `gb_ovest_proj`, mentre per la destinazione usiamo "EPSG:3857". Questa funzione accetta entrambi i tipi di argomenti. Nel caso gli venga passato solo il codice provvederà lei a istanziare la proiezione (solo se non è già presente nella cache delle proiezioni).
6. #23 - Assegniamo alla proprietà di configurazione `center` di `ol.View` le coordinate trasformate, e aumentiamo un po' il livello di zoom

A questo punto la mappa è in grado di posizionarsi correttamente su Firenze.

{% highlight html linenos %}
<body>
  <div id="map" class="map"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.4.4/proj4.js"></script>
  <script src="http://epsg.io/3003.js"></script>
  <script src="../assets/js/ol-debug.js"></script>
  <script>
    var firenze_gbw = [1681450.785672498, 4848967.319261061];
    
    var gb_ovest_proj = new ol.proj.Projection({
      code: "EPSG:3003"
    });
    
    var firenze_gmerc = ol.proj.transform(firenze_gbw, gb_ovest_proj, "EPSG:3857");
    
    var map = new ol.Map({
      layers: [
        new ol.layer.Tile({
          source: new ol.source.OSM()
        })
      ],
      target: 'map',
      view: new ol.View({
        center: firenze_gmerc,
        zoom: 10
      })
    });
  </script>
</body>
{% endhighlight %}
  
{% include jsfiddle.html id="fpbjeycx" %}

Come già detto l'inclusione di proj4js e della definizione del SR è necessario solo se abbiamo necesità di eseguire trasformazioni e/o riproiezioni lato client. Se vogliamo solo assegnare un SR alla mappa o ad un layer è sufficiente creare una `ol.proj.Projection` assegnandogli il codice EPSG.

In questo esempio abbiamo eseguito una trasformazione usando direttamente i valori delle coordinate. Come vedremo più avanti è possibile eseguire trasformazioni anche direttamente su singoli elementi geometrici (punti, linee e poligoni) o su interi strati vettoriali e raster.

# E la scala? #
Una domanda che viene posta spesso dagli utenti dei servizi WebGIS è di poter visualizzare o impostare la _scala geografica_ della mappa. Si capisce questa esigenza, data dalla possibilità di determinare esattamente tale valore sia su supporti fisici che all'interno dei software desktop GIS. Sul web questa richiesta si scontra con un problema fondamentale: non è possibile sapere esattamente la risoluzione (DPI - dots per ingh) dello schermo su cui si sta visualizzando la pagina Web. Spieghiamo cosa significa...

 Per poter determinare la dimensione di un elemente grafico rappresentato su supporto digitale è necessario sapere qual'è il rapporto tra il numero di pixel rappresentati sullo schermo e la loro effettiva dimensione metrica. Conoscendo questo rapporto, appunto i _dots per inch_ (punti per pollice o, tramite conversione, per cm o metro), posso sapere che un oggetto largo 100px avrà una dimensione sullo schermo:
 
 {% highlight javascript %}
 var width = 600; // dimensione mappa in pixel
 var dpi = 90; // risoluzione schermo in pixel per pollice
 var dpc = 90 * 0.393701 // -> 35.43309 risoluzione schermo in pixel per centimetro
 var centimetri_schermo = width / dpc // -> 16.933 dimensione mappa in centimetri
 {% endhighlight %}
 
 Se a questo si abbina l'informazione della _risoluzione_ della nostra mappa, che in OL significa il rapporto metri / pixel del contenuto della mappa, avremmo tutto quello che ci serve per sapere la _scala_ della mappa:
 
  {% highlight javascript %}
 var width = 600; // dimensione oggetto in pixel
 var risoluzione = 2.5; // risoluzione mappa in metri per pixel
 var metri_contenuto = width * risoluzione // -> 1500 dimensione in metri del contenuto della mappa
 var scala = centimetri_schermo / metri_contenuto * 100 // scala mappa, corrispondente ad un rapporto di circa 1:10000
 {% endhighlight %}
 
 <br>
!["Scala mappa"]({{ "/assets/img/scale.png" | relative_url }} "Scala mappa")
<br>

 
 Questo in teoria, ma come abbiamo detto ci manca l'informazione di base: nessuno ci sa dire, all'interno di un browser web, i DPI dello schermo. Ne consegue che **non è possibile determinare con precisione la scala di una mappa all'interno di una pagina Web**.
 Per poter ottenere un valore _indicativo_ si usano valori standard di DPI. Spesso si usa, ad esempio, il valore DPI ottenuto dallo standard WMS di OGC. **WMS 1.3 definisce una dimensione standard del pixel di 0.28mm**, da cui si può ricavare un DPI di `25.4/0.28 = 90.71` pixel / cm.